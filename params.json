{"name":"jQInit.js","tagline":"Small jquery loader working with html5's async","body":"\r\nEverything ASYNC\r\n===============================================================================\r\n\r\n * jsinit.js allows 'async' loading of *every* script in your html header. (Even itself!)\r\n * It is pretty small (about 500 Byte minified)\r\n * It provides dependency checking and some basic dependency injection\r\n * It does nothing which isn't really needed but it can be extended to do more\r\n * It's free as in 'free as a tramp'\r\n\r\n***ALHA***\r\n(just to be sure)\r\n\r\nTry it out:\r\n-------------------------------------------------------------------------------\r\nIn a new browser window open the console and go to: \r\n\r\n(https://rawgit.com/ScheintodX/jqinit.js/master/test.html)\r\n\r\nYou might want to disable caching and turn some throttling on (or use a GRPS net) to see the effect.\r\n\r\nQuickstart\r\n-------------------------------------------------------------------------------\r\n\r\n 1. download <a href=\"jqinit.js\">jqinit.js</a> and put it somewhere (or reference it directly from rawgit.com to try it out. s. below)\r\n\r\n 2. put it and all your modules in the html header like so: (order doesn't matter)\r\n\r\n```\r\n\t<script async src=\"//ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js\"></script>\r\n\t<script async src=\"//rawgit.com/ScheintodX/jqinit.js/master/jqinit.js\"></script>\r\n\t<script async src=\"js/mymodule1.js\"></script>\r\n\t<script async src=\"js/mymodule2.js\"></script>\r\n```\r\n\r\n 3. build your modules like this:\r\n\t\r\n```\r\n\tvar jQInit = jQInit || [];\r\n\r\n\tjQInit.push( [ 'myModule1', function( $ ) {\r\n\r\n\t\t// do stuff including jQuery\r\n\r\n\t} ] );\r\n```\r\n\r\n 4. done. (Really! Want to know more? Read on!)\r\n\r\n\r\n\"Just another JavaScript loader\"?\r\n-------------------------------------------------------------------------------\r\n\r\nQuiet the opposite. There are numerous loaders for JavaScript. This one is different in that it doesn't load anything at all. Instead it lets the browser do all loading (something a browser is very good at) but manages the correct initialization of your modules. As a bonus you get some form of depencency injection. And of cause jqinit.js can be loaded asynchronously, too!\r\n\r\n![Comic](https://rawgit.com/ScheintodX/jqinit.js/master/comic.svg)\r\n\r\nI know that there are solutions out there which are in wide use. I have looked at many of them and they didn't see them fit my needs.\r\n\r\nSome of the limitations I saw:\r\n * Doesn't support async\r\n * Need to put js code in every page\r\n * Way to big\r\n\r\njQuery is all about power in simplicity. So is this loader.\r\n\r\nHtml5 gave us these nice tiny extension to the `<script>` tag called `defer` and `async`. But you can't use it to load jQuery because every plugin to jQuery needs jQuery to be there in the first place. So no way to load jQuery *after* it's modules, isn't it?\r\n\r\nImagine:\r\n * Being able to load jQuery and dependent modules async in arbitrary order.\r\n * Having a well defined format for your own modules which can be loaded async\r\n * Being able to load modules when they are needed.\r\n * Don't have to care about order of initialization at all.\r\n * Don't have to put scripts in every html page (s. ready.js)\r\n * Using google's hosting for the jQuery core libs\r\n * Have a simple mechanism of dependency injection as a bonus.\r\n * Have a standard module format which encourages best practice and supports minification.\r\n * Having all modules accessible under one namespace\r\n * Doing all this in about 550 bytes (and that can still be optimized)\r\n * And the best: Have the \"Loader\" itself being loaded asynchronously.\r\n\r\nSo why did I put the word \"Loader\" in ampersands? Because what it does is rather the opposite of loading something. Indeed it lets all the loading do the browser which has very nifty methods of doing so. (Lookahead scanners and so on.)\r\n\r\nWhat it does is simply making sure that everything which has been loaded is initialized and executed in the correct order. And all of this in just a few lines of javascript. So lets call that thing: \"jQInit\" for now.\r\n\r\n\r\nSo how does it look like?\r\n-------------------------------------------------------------------------------\r\n\r\nSimple: Put your stuff in the html header like you are used to, but add async:\r\n\r\n\t<script async src=\"//google/jQuery\"></script>\r\n\t<script async src=\"/js/jqinit.js\"></script>\r\n\t<script async src=\"/js/module1.js\"></script>\r\n\t<script async src=\"/js/module2.js\"></script>\r\n\r\nLooks simple. But just to make a point, you can have written it this way, too:\r\n\r\n\t<script async src=\"/js/module1.js\"></script>\r\n\t<script async src=\"/js/module2.js\"></script>\r\n\t<script async src=\"/js/jqinit.js\"></script>\r\n\t<script async src=\"//google/jQuery\"></script>\r\n\r\nor any other order you want. (Think about it. This is the very nature of *async* loading ...)\r\n\r\nSo how can a js module do this without being loaded itself? Sure there is a gotcha ... and well ... you have to do \"something\" of cause.\r\n\r\nBut rest assured this something are just a few bytes. So lets look at the module format:\r\n\r\nYou're of cause familiar with the simple module pattern:\r\n\r\n\tvar MyModule = (function($){\r\n\r\n\t\t// do stuff here\r\n\t\treturn {\r\n\t\t\t// put public stuff there\r\n\t\t}\r\n\r\n\t})(jQuery);\r\n\r\nSo let's extend this with dependencies and while where at it inject them as well:\r\n\r\n\tvar MyModule = [ 'MyModule', 'MyOtherModule', function( MyOtherModule, $ ){\r\n\r\n\t\t// follow pattern\r\n\r\n\t} ];\r\n\r\nSo this defines a module with the name of 'MyModule' and an dependency on 'MyOtherModule' (and of cause jQuery, this is what this is all about). \r\n\r\nBut there is no execution of this code right there, isn't it? We'll get there in a moment. What we first need is \"something\" to store that stuff into. So lets create an array for that, but only it its not already there:\r\n\r\n\tvar jQInit = jQInit || [];\r\n\r\nand put our module in:\r\n\r\n\tjQInit.push( [ 'MyModule', 'MyOtherModule', function( MyOtherModule, $ ){\r\n\r\n\t\t// follow pattern\r\n\r\n\t} ] );\r\n\r\n*And that's it.* Yes right. There is nothing more you have to do in a module. This one can be loaded asynchronously.\r\n\r\n\r\nHow does it work?\r\n-------------------------------------------------------------------------------\r\n\r\nSo what is missing now? The magic of cause. This comes in when look at what jqinit.js does:\r\n\r\nFor starters jQInit itself follows normal module pattern (of cause it doesn't need to register itself):\r\n\r\nLet's have a look into it. This is the most important part:\r\n\r\njQInit.js:\r\n\r\n\tvar jQInit = (function( _jQInit ) {\r\n\r\n\t\t// in case we are executed first\r\n\t\t_jQInit = _jQInit || [];\r\n\r\n\t\t// initialize dependencies which are already there\r\n\t\tinitializeModulesIfDependenciesAreMet();\r\n\r\n\t\t// do the magic:\r\n\t\treturn {\r\n\t\t\t// Simulate an array\r\n\t\t\tpush: function( module ) {\r\n\r\n\t\t\t\t// Store in array\r\n\t\t\t\t_jQInit.push( module );\r\n\r\n\t\t\t\t// intialize newly pushed modules and others which are waiting for their dependencie:\r\n\t\t\t\tinitializeModulesIfDependenciesAreMet();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t} )( jQInit );\r\n\r\nSo it essentially swaps the array we used in the modules (remember: if it doesn't existed we simply created one) with its own structure.\r\n\r\nThen it simulates the only array operation we need: `push()`. So if it is executed before some of our modules are loaded the method to register them stays the same but now we can initialize them right away.\r\n\r\n\r\nLimitations / Possible extensions:\r\n-------------------------------------------------------------------------------\r\n\r\nCurrently this doesn't work without some \"hackery\" for jQuery Modules like Mobile or UI. This is because they don't follow any module syntax like it would be needed.\r\nTherefor an extra module is provided: jqinit.loader.js.\r\nIt uses jQuery to load them and is only a few bytes long. The main drawback is that the modules's loading is delayed until jQuery is done loading. This is needed because the modules need jQuery to be there before they can start executing. So there is a slight delay here. Of cause this situation would improve greatly if jqinit would be absorbed in jQuery itself and the jQuery modules would follow it's module semantics.\r\n\r\nSome jQuery plugins (e.g. mobile) must be configured before they are loaded/executed. There should be a standard way for this kind of stuff. Currently one can use jqinit.loader.js to achieve this.\r\n\r\nOne possible extension could be a simple way of loading modules while the application is already running. In the current state it is already as simple as `$('head').append( '<script src=\"/js/somescript.js\"></script>' )` or `jQuery.getScript( 'js/somescript.js' )`. jqinit.loader.js provides another such a function (`Loader.load()`). Most probably that's already enough.\r\n\r\nSomething I haven't even begun to think about is \"dependency-loading\". So there is currently no external definition of dependencies on a per file-basis. I like it this way because it keeps things simple but one could think about having some module-definition like: `{ ModA: \"/js/moda.js\", ModB: ... }` and have jQInit load them on demand according to dependencies. This certainly makes only sense for modules which aren't loaded anyway. But it could provide useful for large apps. But I think this could be added easily as plugin if needed.\r\n\r\nSomething I intend to look into further is a way of passing content loaded via ajax/Loader to the modules so that they can do (re)initialization on it.\r\n\r\nThere could be a need to \"unload\" modules. Let me know if you'd need that.\r\n\r\nThere are many things e.g. RequireJS can do what jqinit.js cannot. This is on purpose because we want to keep it as small as possible.\r\n\r\nHow do I do?\r\n===============================================================================\r\n\r\nWhat to put in my html5 page?\r\n-------------------------------------------------------------------------------\r\n\r\nSimple. Just put the jQuery, jqinit.js and your own modules in `<script>` tags in the header. This should look like:\r\n\r\n\t<script src=\"//google/jQuery\" async></script>\r\n\t<script src=\"/js/jqinit.js\" async></script>\r\n\t<script src=\"/js/module1.js async></script>\r\n\t<script src=\"/js/module2.js async></script>\r\n\r\nIt is a good idea to put jQuery first but it makes no big difference. The whole purpose of this lib is that it makes no difference.\r\n\r\n\r\nHow do I write a module?\r\n-------------------------------------------------------------------------------\r\n\r\nThe simplest possible module would look like this:\r\n\r\nmymodule.js:\r\n\r\n\tvar jQInit = jQInit || [];\r\n\r\n\tjQInit.push( [ 'MyModule', function( $ ) {\r\n\r\n\t\t// code goes here\r\n\t}\r\n\r\nBut for your convenience I have although a basic pattern for you which shows a little more what you can do:\r\n\r\nmymodule.js:\r\n\r\n\t\"use strict\";\r\n\r\n\tvar jQInit = jQInit || [];\r\n\r\n\tjQInit.push( [ 'MyModule', function( $ ) {\r\n\r\n\t\t// private stuff here\r\n\r\n\t\tfunction init() {\r\n\r\n\t\t\t// this is called in $(document).ready()\r\n\t\t}\r\n\r\n\t\tvar module = {\r\n\r\n\t\t\t// public stuff here\r\n\r\n\t\t\t//e.g.\r\n\t\t\tdoPublicly: function(){\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t$( init ); // register init via jQuery.ready\r\n\r\n\t\treturn module;\r\n\r\n\t} ] );\r\n\r\nof cause you could put `init` in `module` and make it public this way.\r\n\r\nWhat about dependencies / dependency injection?\r\n-------------------------------------------------------------------------------\r\n\r\nOne part of jQInit's work is to check dependenc in order to only execute modules which have all dependencies met.\r\n\r\nSo to tell jQInit what is needed just put your dependencies in like that:\r\n\r\n\tjQInit.push( [ 'MyModule', 'MyFirstDependency', 'MySecondDependency', function( $ ) { ...\r\n\r\nand jQInit knows that these modules have to be initialized first.\r\n\r\nIf you not only want them to be initialized but also want to use them, just put them as arguments in the creator function\r\nand their public methods will be available:\r\n\r\n\tjQInit.push( [ 'MyModule', 'First', 'Second', function( $, first, second ) {\r\n\r\n\t\tfirst.doSomething();\r\n\r\n\t\tsecond.doSomethingelse();\r\n\t}\r\n\r\n\r\nHow do I load jQueryUI / jQueryMobile etc.?\r\n-------------------------------------------------------------------------------\r\n\r\nThis one is a bit tricky. Since they don't follow this pattern they can't be loaded asynchronously right away. This could improve if the jQuey people decided to put a loader like this directly in jQuery. For now you can use jqinit.loader.js` in that way:\r\n\r\n\r\nloadlibs.js:\r\n\r\n\t\"use strict\";\r\n\r\n\tvar jQInit = jQInit || [];\r\n\r\n\tjQInit.push( [ 'LoadLibs', 'Loader', function( $, Loader ){\r\n\r\n\t\tLoader.load( \"JQuery.Mobile\", \"https://ajax.googleapis.com/ajax/libs/jquerymobile/1.4.3/jquery.mobile.min.js\" )\r\n\t\t      .load( \"JQuery.Validate\", \"//ajax.aspnetcdn.com/ajax/jquery.validate/1.9/jquery.validate.js\" )\r\n\t\t      ;\r\n\r\n\t} ] );\r\n\r\n\r\nBy the way: have a look at jqinit.loader.js code. There is not much to it. It itself is a jqinit module and you can just copy it and extend it if you need to.\r\n\r\n\r\nAnd when I need jQueryUI / jQueryMobile for my Modules to work?\r\n-------------------------------------------------------------------------------\r\n\r\nFear not. `jqinit.loder.js` to the rescue. As you can see in the code above every dependency you load gets a unique name. For the sake of this example we named them `JQuery.Mobile` and `JQuery.Validate` but you can name them whatever you want.\r\n\r\nThe only other thing you have to do is put them into your module as dependency like so:\r\n\r\n\tjQInit.push( [ 'MyModule', 'JQuery.Mobile', 'JQuery.Validate', function( $, first, second ) { ...\r\n\r\n\r\nHow do I access my Module / check if my module has been loaded?\r\n-------------------------------------------------------------------------------\r\n\r\nSo know you have loaded your module and returned some structure from it. But how to access it anyway?\r\n\r\nNormally you don't have to call it directly because you can use dependency injection for that. But if you insist:\r\n\r\njQInit keeps track of every module it has loaded and keeps them as key. Simply call for it this way:\r\n\r\n\tjQInit.MyModule.doStuff()\r\n\r\nor via string:\r\n\r\n\tjQInit['MyModule'].meaning = 42;\r\n\r\n\r\nto see if something is loaded just check it with:\r\n\r\n\tif( jQInit.MyModule ) { ... do something ... }\r\n\r\n\r\nHow do I do something after *everything* has loaded?\r\n-------------------------------------------------------------------------------\r\n\r\nThe real question here is: When is everything loaded? The very nature of this library is to make sure the stuff which is loaded is executed in the correct order. And because everything is loaded asynchronously it has no means of knowing what there is to come. So if you decide while you are running your app that you need to load some more modules, you can do so and they will be integrated.\r\n\r\nBut feat not. There is a simple solution. When you say *everything* you normally have an idea what this everything is. So lets say you have 3 Modules: \r\n\r\n\tFirst\r\n\t\t<- Second\r\n\t\t<- Third\r\n\r\nwhere `Second` and `Third` depend on `First`.\r\n\r\nJust throw in an fourth module like so:\r\n\r\n\tjQInit.push( [ 'Fourth', 'Second', 'Third' function( $ ){\r\n\r\n\t\t// This is executed after all three other modules have loaded\r\n\t}\r\n\r\nYou don't need to specify `First` because the dependency mechanism will do that for you.\r\n\r\n\r\nHow do I minify stuff / put it all together?\r\n-------------------------------------------------------------------------------\r\n\r\nThat depends. Firstly the module format enables heavy minification because there are hardly global variables which need to keep their names. (And it is best practice to keep it that way. So put most of your code in the private area of a module.\r\n\r\nThen just use your minification-tool of choise or any online minification service.\r\n\r\nIf you have written many modules and want to minify them you simply can concatenate them in one file and minify that. The order in which you do that is not important. Put jsinit.js in there, too. But you don't have to. Sometimes it is easier to find bugs if you have a file to point to. An sometimes (dependent on your setup) it is faster to have some more files which can be loaded in parallel.\r\n\r\nThere is a light redundancy if putting it all in one file: `\"use strict\"` and `var jQInit = jQInit || []` will be there multiple times. Normally gzip will take care of that and it will make no big difference. But if every byte counts you could put jqinit.js in first and remove all occurrences both of those snippets.\r\n\r\n\r\nWhat is the state of this project?\r\n-------------------------------------------------------------------------------\r\n\r\nCurrently I call it *PRE ALPHA* just because it is so new and I want to be able to change stuff without notice if I see the need to.\r\nBut it's not much code at all. So just copy it and patch it as you want.\r\n\r\nThere is room for improvement:\r\n\r\nFirstly not very much has been done to reduce size. Currently readability matters more. But again: There is nothing here to stop you shrinking it.\r\n\r\nSecondly: I'm not the best Javascript coder under the sun. So if you find something which can be written more clearly / faster / better / greater just do it and send me your patch. If it doesn't extend the scope I will gladly put it in. \r\n\r\n\r\nHow do I notify jQInit that I have loaded another dependency which doesn't follow pattern?\r\n-------------------------------------------------------------------------------\r\n\r\nThis is what `jqinit.loader.js` does. Remember: jqinit replaces the array you created in your modules with it's own structure where it defines a `push` function in order to be compatible with array.\r\n\r\nIn addition to that function it although defines a `register` function with this syntax: `register( name, module ). All that this does is remember the provided modules under the given name (as it would have done with push and the returned module from the creator function) and initialize modules which may depend on it.\r\n\r\nThis is exacly what `jqinit.loader.js` does: load a javascript file and register it's result under the name given.\r\n\r\n\r\nWhat are the main differences / advantages via RequireJS\r\n-------------------------------------------------------------------------------\r\n\r\nRequireJS has been there for a long while and it's great. It can do many things jqinit.js cannot. But this is on purpose because it followes another scope than jqinit.js.\r\n\r\nRequireJS is good if you:\r\n * do large web application where it's additional size doesn't matter \r\n * use node.js\r\n * have many libraries from many different sources\r\n * want to be able to configure things\r\n * are forced to use what's called \"standard\" (AMD in this case)\r\n\r\njqinit.js is good if you:\r\n * do small to large websites where size does matter.\r\n * care about loading speed. E.g. for mobile in slow networks.\r\n * have mostly jQuery and your own modules and a few others which you might be able to patch. \r\n * don't want to care to much about configuration but want something that \"just works\".\r\n * are free to use what works for you\r\n\r\n\r\nCan I combine jqinit and RequireJS?\r\n-------------------------------------------------------------------------------\r\n\r\nEven though I haven't looked deep into this, I see no real reason why you shouldn't. There is nothing what could stop you loading jqinit modules with RequireJS.\r\n\r\nPerhaps there will be an RequireJS adaptor to jqinit sometimes.\r\n\r\n\r\nWhy not use AMD module format\r\n-------------------------------------------------------------------------------\r\n\r\nI would love to. Problem is: It won't work.\r\n\r\nAMD uses the `define()` function to define a module. In order to be able to use this it has to be defined before the module is loaded. So RequireJS needs to be loaded before any other module. This prevents it from beeing loaded `async`.\r\n\r\n\r\nWhy not a general purpose loader but only for jQuery?\r\n-------------------------------------------------------------------------------\r\n\r\nFirst of all: It's not a loader and not intended to be one. \r\n\r\nThat said: The main reason it's only for jQuery is, that I only need it to be for jQuery. I think most people today use it for jQuery. Other frameworks (e.g. Angular) have their own ideas of how a module should look like and already have their DI in place there. \r\n\r\nFinally I'm still hoping that the jQuery people would put a system like it in the core sometimes. As fewer it does as higher the possibility for such a move is.\r\n\r\n\r\nAnd what is the image about?\r\n-------------------------------------------------------------------------------\r\n\r\nSince you asked: The image is my recreation of an panel from the famous graphic novel: \"Asterix and the Goths\" from RenÃ© Goscinny and Albert Uderzo. Asterix and his friend Obelix accompany thier druid \"Getafix\" to the annual druid' conference where the druids present their best work. One of them manages to reduce soup to just a powder which is as he says easier to carry around than a cauldron. Hinted that he still needs a cauldron to recreate his soup he tells the amazed audience that he found a way to even reduce the cauldron to a powder.\r\n\r\nThis is meant as a reference to the \"asynchronous loader\" which is loaded asynchronously itself.\r\n\r\nIn the end the winner is of cause Getafix with his magic potion. So the powdered cauldron wasn't so ingenious after all. (I wonder why?)\r\n\r\nI can't put the original image in here because of copyright laws which forbid citations if they are only for entertaining purposes -- at least by german laws. So I had to recreate it.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}